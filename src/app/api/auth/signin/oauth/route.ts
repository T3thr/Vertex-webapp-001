// src/app/api/auth/signin/oauth/route.ts
// API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö/‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏ú‡πà‡∏≤‡∏ô OAuth providers (Google, Twitter, etc.)
// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô‡πÇ‡∏î‡∏¢‡∏≠‡∏≤‡∏®‡∏±‡∏¢ Mongoose Schema Defaults ‡πÅ‡∏•‡∏∞ pre-save hook
// ‡∏à‡∏≤‡∏Å User Model ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á/‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏™‡∏≠‡∏î‡∏Ñ‡∏•‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î

import { NextResponse } from "next/server";
import dbConnect from "@/backend/lib/mongodb";
import UserModel, { IUser, IAccount } from "@/backend/models/User"; // << ‡∏•‡∏î‡∏Å‡∏≤‡∏£ import ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
import { Types, Document } from "mongoose";

interface OAuthSignInRequestBody {
  provider: string;
  providerAccountId: string;
  email?: string | null;
  name?: string | null;
  usernameSuggestion?: string | null;
  picture?: string | null;
  "error-codes"?: string[];
}

type PlainUserObjectData = Omit<
  IUser,
  keyof Document | // Omit Mongoose Document specific keys if IUser itself doesn't directly extend it for this purpose
  '_id' | // We'll handle _id separately as string
  'matchPassword' | // Exclude methods
  'generateEmailVerificationToken' |
  'generatePasswordResetToken'
>;

type OAuthSignInResponseUser = PlainUserObjectData & {
  _id: string;
  accounts: IAccount[]; // IAccount ‡∏à‡∏≤‡∏Å toObject() ‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô plain object
};

async function generateUniqueUsername(baseUsername: string): Promise<string> {
  let currentUsername = baseUsername.toLowerCase().replace(/[^a-z0-9_.]/g, "").substring(0, 40);
  if (currentUsername.length < 3) {
    currentUsername = `${currentUsername}${Math.random().toString(36).substring(2, 5)}`;
  }
  currentUsername = currentUsername.substring(0, 50);

  let counter = 0;
  let uniqueUsername = currentUsername;

  // The eslint-disable directive for no-constant-condition was removed as per the warning.
  // If 'no-constant-condition' is an active error rule in your project for 'while(true)',
  // and you intend for this loop to be infinite until broken, you might need to re-evaluate
  // your ESLint setup or the loop's condition if the warning was misleading.
  // For now, assuming removal is correct based on "no problems were reported".
  while (true) {
    const existingUser = await UserModel.findOne({ username: uniqueUsername }).lean();
    if (!existingUser) {
      break;
    }
    counter++;
    const baseForNew = currentUsername.substring(0, 50 - (String(counter).length + 1));
    uniqueUsername = `${baseForNew}_${counter}`;
    if (uniqueUsername.length > 50) {
        uniqueUsername = `user_${Date.now().toString().slice(-7)}_${counter}`;
    }
  }
  return uniqueUsername;
}

export async function POST(request: Request): Promise<NextResponse> {
  let wasNewlyCreated = false;
  await dbConnect();
  console.log("üîµ [API:OAuthSignIn] ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MongoDB ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");

  try {
    const body = (await request.json()) as OAuthSignInRequestBody;
    const { provider, providerAccountId, email, name, usernameSuggestion, picture } = body;

    console.log(`‚ÑπÔ∏è [API:OAuthSignIn] ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö request ‡∏à‡∏≤‡∏Å provider: ${provider}, providerAccountId: ${providerAccountId}, email: ${email}`);

    if (!provider || !providerAccountId) {
      console.error("‚ùå [API:OAuthSignIn] ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô: provider ‡∏´‡∏£‡∏∑‡∏≠ providerAccountId ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤");
      return NextResponse.json(
        { error: "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Provider ‡∏´‡∏£‡∏∑‡∏≠ Provider Account ID ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" },
        { status: 400 }
      );
    }
    if (!email && !usernameSuggestion && !name && provider !== "twitter") {
        console.error("‚ùå [API:OAuthSignIn] ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠ (‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ email ‡∏´‡∏£‡∏∑‡∏≠ name/usernameSuggestion)");
        return NextResponse.json(
          { error: "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Provider ‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠ (‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ email ‡∏´‡∏£‡∏∑‡∏≠ name)" },
          { status: 400 }
        );
    }

    // ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç Type ‡∏Ç‡∏≠‡∏á userDocument: ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å IUser extends Document, ‡πÄ‡∏£‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ IUser | null ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
    let userDocument: IUser | null = await UserModel.findOne({
      "accounts.provider": provider,
      "accounts.providerAccountId": providerAccountId,
    });

    if (userDocument) {
      console.log(`‚úÖ [API:OAuthSignIn] ‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏î‡∏¥‡∏°‡∏î‡πâ‡∏ß‡∏¢ ${provider} ID: ${providerAccountId} (Username: ${userDocument.username})`);

      if (!userDocument.isActive) {
        console.warn(`‚ö†Ô∏è [API:OAuthSignIn] ‡∏ö‡∏±‡∏ç‡∏ä‡∏µ (‡πÄ‡∏î‡∏¥‡∏°) ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô: ${userDocument.username}`);
        return NextResponse.json({ error: "‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô" }, { status: 403 });
      }
      if (userDocument.isBanned) {
        const banMessage = userDocument.bannedUntil ? `‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ñ‡∏π‡∏Å‡∏£‡∏∞‡∏á‡∏±‡∏ö‡∏ñ‡∏∂‡∏á ${new Date(userDocument.bannedUntil).toLocaleString("th-TH")}` : "‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ñ‡∏π‡∏Å‡∏£‡∏∞‡∏á‡∏±‡∏ö‡∏ñ‡∏≤‡∏ß‡∏£";
        console.warn(`‚ö†Ô∏è [API:OAuthSignIn] ‡∏ö‡∏±‡∏ç‡∏ä‡∏µ (‡πÄ‡∏î‡∏¥‡∏°) ‡∏ñ‡∏π‡∏Å‡πÅ‡∏ö‡∏ô: ${userDocument.username}`);
        return NextResponse.json({ error: banMessage, banReason: userDocument.banReason }, { status: 403 });
      }

      let updated = false;
      if (email && userDocument.email !== email.toLowerCase()) {
        if (!userDocument.email || !userDocument.isEmailVerified) {
          const existingEmailUser = await UserModel.findOne({ email: email.toLowerCase(), _id: { $ne: userDocument._id } });
          if (!existingEmailUser) {
            userDocument.email = email.toLowerCase();
            userDocument.isEmailVerified = true;
            userDocument.emailVerifiedAt = new Date();
            updated = true;
            console.log(`üîÑ [API:OAuthSignIn] ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ${userDocument.username} ‡πÄ‡∏õ‡πá‡∏ô ${email}`);
          } else {
            console.warn(`‚ö†Ô∏è [API:OAuthSignIn] ‡∏≠‡∏µ‡πÄ‡∏°‡∏• ${email} ‡∏à‡∏≤‡∏Å ${provider} ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß‡πÇ‡∏î‡∏¢‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏≠‡∏∑‡πà‡∏ô ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÑ‡∏î‡πâ`);
          }
        }
      } else if (email && !userDocument.email) {
         const existingEmailUser = await UserModel.findOne({ email: email.toLowerCase(), _id: { $ne: userDocument._id } });
        if (!existingEmailUser) {
          userDocument.email = email.toLowerCase();
          userDocument.isEmailVerified = true;
          userDocument.emailVerifiedAt = new Date();
          updated = true;
          console.log(`‚ûï [API:OAuthSignIn] ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏µ‡πÄ‡∏°‡∏• ${email} ‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ${userDocument.username}`);
        } else {
            console.warn(`‚ö†Ô∏è [API:OAuthSignIn] ‡∏≠‡∏µ‡πÄ‡∏°‡∏• ${email} ‡∏à‡∏≤‡∏Å ${provider} ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß‡πÇ‡∏î‡∏¢‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏≠‡∏∑‡πà‡∏ô ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏î‡πâ`);
        }
      }

      if (userDocument.profile) {
          if (name && !userDocument.profile.displayName) {
            userDocument.profile.displayName = name;
            updated = true;
          }
          if (picture && !userDocument.profile.avatarUrl) {
            userDocument.profile.avatarUrl = picture;
            updated = true;
          }
      } else {
          // Mongoose subdocuments (like profile) are automatically initialized
          // if their schema has defaults or they are assigned an object.
          // If profile can be undefined in IUser and the schema doesn't auto-create it,
          // this direct assignment is correct.
          userDocument.profile = {
              displayName: name || undefined,
              avatarUrl: picture || undefined,
              gender: "prefer_not_to_say", // Default
          };
          updated = true;
      }

      userDocument.lastLoginAt = new Date();
      await userDocument.save();
      console.log(`üîÑ [API:OAuthSignIn] ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï lastLoginAt ${updated ? '‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∑‡πà‡∏ô‡πÜ ' : ''}‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ${userDocument.username}`);

    } else {
      if (email) {
        const existingUserWithEmail = await UserModel.findOne({ email: email.toLowerCase() });
        if (existingUserWithEmail) {
          userDocument = existingUserWithEmail; // existingUserWithEmail is IUser | null
          console.log(`üîó [API:OAuthSignIn] ‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏î‡πâ‡∏ß‡∏¢‡∏≠‡∏µ‡πÄ‡∏°‡∏• ${email} (Username: ${userDocument.username}), ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ö‡∏±‡∏ç‡∏ä‡∏µ ${provider}`);

          if (!userDocument.isActive) return NextResponse.json({ error: "‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÇ‡∏¢‡∏á‡∏î‡πâ‡∏ß‡∏¢‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô" }, { status: 403 });
          if (userDocument.isBanned) return NextResponse.json({ error: "‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÇ‡∏¢‡∏á‡∏î‡πâ‡∏ß‡∏¢‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏£‡∏∞‡∏á‡∏±‡∏ö" }, { status: 403 });

          const accountExists = userDocument.accounts.some(
            acc => acc.provider === provider && acc.providerAccountId === providerAccountId
          );

          if (!accountExists) {
            const newAccountObject: IAccount = {
              provider,
              providerAccountId,
              type: "oauth",
            } as IAccount; // Mongoose subdocument array handles this correctly
            userDocument.accounts.push(newAccountObject);

            if (!userDocument.isEmailVerified) {
                userDocument.isEmailVerified = true;
                userDocument.emailVerifiedAt = new Date();
            }
            if (userDocument.profile) {
                if (name && !userDocument.profile.displayName) userDocument.profile.displayName = name;
                if (picture && !userDocument.profile.avatarUrl) userDocument.profile.avatarUrl = picture;
            } else {
                userDocument.profile = { displayName: name || undefined, avatarUrl: picture || undefined, gender: "prefer_not_to_say" };
            }

            userDocument.lastLoginAt = new Date();
            await userDocument.save();
            console.log(`‚úÖ [API:OAuthSignIn] ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ö‡∏±‡∏ç‡∏ä‡∏µ ${provider} ‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ${userDocument.username} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`);
          } else {
            console.log(`‚ÑπÔ∏è [API:OAuthSignIn] ‡∏ö‡∏±‡∏ç‡∏ä‡∏µ ${provider} ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ${userDocument.username} ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß`);
            userDocument.lastLoginAt = new Date(); // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï lastLoginAt ‡πÅ‡∏°‡πâ‡∏ß‡πà‡∏≤‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏à‡∏∞‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
            await userDocument.save();
          }
        }
      }

      if (!userDocument) {
        wasNewlyCreated = true;
        console.log(
          `‚ú® [API:OAuthSignIn] ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ, ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å ${provider} ‡∏î‡πâ‡∏ß‡∏¢ email: ${email}, name: ${name}`
        );

        const newUsernameBase =
          usernameSuggestion ||
          (email ? email.split("@")[0] : "") ||
          name?.replace(/\s+/g, "") ||
          `user${Date.now().toString().slice(-6)}`;
        const finalUsername = await generateUniqueUsername(newUsernameBase);

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏´‡∏°‡πà‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
        // Schema defaults ‡πÅ‡∏•‡∏∞ pre-save hook ‡πÉ‡∏ô User.ts ‡∏à‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        // ‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á sub-documents, ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ default, ‡πÅ‡∏•‡∏∞‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Level 1
        const newUserInput = {
          username: finalUsername,
          email: email ? email.toLowerCase() : undefined,
          isEmailVerified: !!email,
          emailVerifiedAt: email ? new Date() : undefined,
          accounts: [{ provider, providerAccountId, type: "oauth" } as IAccount],
          profile: {
            displayName: name || finalUsername,
            avatarUrl: picture || undefined,
          },
          lastLoginAt: new Date(),
          // Mongoose ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ default ‡∏à‡∏≤‡∏Å UserSchema ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö field ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        };

        if (newUserInput.email) {
          const existingEmailUser = await UserModel.findOne({
            email: newUserInput.email,
          });
          if (existingEmailUser) {
            console.error(`‚ùå [API:OAuthSignIn] ‡∏Ç‡∏ì‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏´‡∏°‡πà ‡∏≠‡∏µ‡πÄ‡∏°‡∏• ${newUserInput.email} ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß (race condition)`);
            return NextResponse.json({ error: `‡∏≠‡∏µ‡πÄ‡∏°‡∏• ${newUserInput.email} ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß‡πÇ‡∏î‡∏¢‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏≠‡∏∑‡πà‡∏ô.` }, { status: 409 });
          }
        }

        // UserModel constructor expects a type compatible with IUser's schema definition.
        // The 'as IUser' cast might be needed if newUserInput isn't perfectly matching or if strict type checking is very high.
        // However, Mongoose is generally flexible.
        userDocument = new UserModel(newUserInput);
        await userDocument.save();
        console.log(`‚úÖ [API:OAuthSignIn] ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏´‡∏°‡πà ${userDocument.username} ‡∏à‡∏≤‡∏Å ${provider} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`);
      }
    }

    if (!userDocument) {
        console.error("‚ùå [API:OAuthSignIn] ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏£‡πâ‡∏≤‡∏¢‡πÅ‡∏£‡∏á: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏´‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á User document ‡πÑ‡∏î‡πâ");
        return NextResponse.json({ error: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö OAuth ‡πÑ‡∏î‡πâ" }, { status: 500 });
    }

    // userDocument is of type IUser (which extends Mongoose.Document)
    const plainUserObject = userDocument.toObject<IUser>(); // Convert Mongoose document to plain object

    // Destructure to remove Mongoose-specific or method fields for the response
    const {
        _id: objectId, // Mongoose _id is Types.ObjectId
        accounts: originalAccounts, // This will be an array of plain objects after toObject()
        // Exclude methods defined in IUser that are not part of PlainUserObjectData
        matchPassword, // Example method from IUser that should be excluded
        generateEmailVerificationToken, // Example method
        generatePasswordResetToken, // Example method
        // Exclude fields from mongoose.Document that are not in PlainUserObjectData
        // (Many are handled by Omit<IUser, keyof Document ...> in PlainUserObjectData type)
        __v, // Example version key
        $isNew, // Example Mongoose internal
        // ... any other Mongoose document specific fields or methods not wanted in response
        ...restOfUserObject
    } = plainUserObject;


    const userResponse: OAuthSignInResponseUser = {
      ...(restOfUserObject as PlainUserObjectData), // Cast the rest to ensure it matches
      _id: objectId.toString(), // Convert ObjectId to string for JSON response
      // Ensure accounts are plain objects if they weren't fully converted by toObject() for subdocuments
      accounts: originalAccounts.map(acc => {
          // If IAccount subdocuments have their own toObject, it would have been called.
          // This is a safeguard or explicit conversion if needed.
          const plainAcc = { ...acc };
          // If IAccount has methods or Mongoose specifics, omit them here too.
          // For this example, assume IAccount from toObject() is already plain enough.
          return plainAcc as unknown as IAccount; // Cast to IAccount (plain object version)
      }),
    };

     // ‡∏•‡∏ö password field ‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡∏°‡∏µ (‡∏ã‡∏∂‡πà‡∏á‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡∏°‡∏µ‡πÉ‡∏ô OAuth user)
    if ('password' in (userResponse as any)) {
        delete (userResponse as any).password;
    }


    console.log(`‚úÖ [API:OAuthSignIn] ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ${userResponse.username} ‡∏Å‡∏•‡∏±‡∏ö (ID: ${userResponse._id})`);
    return NextResponse.json({ user: userResponse }, { status: wasNewlyCreated ? 201 : 200 });

  } catch (error: any) {
    console.error("‚ùå [API:OAuthSignIn] ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î:", error.message, error.stack);
    if (error.code === 11000) { // MongoDB duplicate key error
        const field = Object.keys(error.keyValue)[0];
        const message = `${field === 'email' ? '‡∏≠‡∏µ‡πÄ‡∏°‡∏•' : (field === 'username' ? '‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ' : `‡∏ü‡∏¥‡∏•‡∏î‡πå '${field}'`)} ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß`;
        return NextResponse.json({ error: message }, { status: 409 });
    }
    return NextResponse.json(
      { error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• Social Sign-In", details: error.message },
      { status: 500 }
    );
  }
}